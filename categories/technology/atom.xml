<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technology | David Souther]]></title>
  <link href="http://DavidSouther.github.io/categories/technology/atom.xml" rel="self"/>
  <link href="http://DavidSouther.github.io/"/>
  <updated>2014-02-18T08:51:44-05:00</updated>
  <id>http://DavidSouther.github.io/</id>
  <author>
    <name><![CDATA[David Souther]]></name>
    <email><![CDATA[davidsouther@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5 Surprisingly Not That Painful Things About Client-side JS]]></title>
    <link href="http://DavidSouther.github.io/2014/02/5-surprisingly-not-that-painful-things-about-client-side-js"/>
    <updated>2014-02-17T22:33:25-05:00</updated>
    <id>http://DavidSouther.github.io/2014/02/5-surprisingly-not-that-painful-things-about-client-side-js</id>
    <content type="html"><![CDATA[<p>I&rsquo;m a huge fan of <a href="http://angularjs.org/">AngularJS</a>. Over at <a href="https://sourcegraph.com/">Sourcegraph</a>,
they seem to be <a href="https://sourcegraph.com/blog/switching-from-angularjs-to-server-side-html">having some problems</a>. Never one to back down from a
holy war, I&rsquo;ll post a rebuttal for how we&rsquo;re using Angular to great effect at
<a href="http://novus.com">Novus</a>, and how we&rsquo;ve gotten around the problems they mention.</p>

<!--more-->


<ol>
<li><p><strong>Bad search ranking and Twitter/Facebook previews</strong></p>

<p> Sourcegraph thinks it&rsquo;s hard to present a reasonable SPA (Single-Page web Application) to crawlers, and
 they&rsquo;re absolutely correct. Especially for a site like theirs, which is creating
 large amounts of dynamic content with few caching opportunities, rendering a
 page for a crawler is expensive and will probably only be used a single time.
 Their analysis of the solutions, either rewriting all your pages server side or
 handling a farm of headless browsers to pre-render for the server are about the
 only ways to handle the situation.</p>

<p> This is a problem, and something that is being actively pursued by the
 community. For Novus, however, we sidestep this. The places we need search
 rankings, we publish a static site. Our primary application is for our customers
 only, and even if you did crawl it, you&rsquo;d get a bunch of nvd3 graphs and charts.
 Actually, I&rsquo;ll go even further for this. In the places you need SEO, you are
 probably better using a static site generator &ndash; the SPA architecture is for
 long-lived, data heavy, dynamic pages. I love angular, but this site is run on
 <a href="http://jekyllrb.com/">Jekyll</a>.</p></li>
<li><p><strong>Flaky stats and monitoring</strong></p>

<p> Sourcegraph argues that it&rsquo;s hard to integrate a third-party analytics provider
 with an SPA. There are tricky issues with the HTML5 history api, and what about
 the replaceState events? When you found out you tracked it wrong, it&rsquo;s nigh
 impossible to recover those stats.</p>

<p> This argument is dubious to me, at best. I can see that tacking tracking on
 after the fact can get tricky. At Novus, we&rsquo;ve got very clear eventing seams,
 which make obvious where to attach tracking hooks. We test our tracking hooks
 during our regression tests (that&rsquo;s a blog post for itself). I wouldn&rsquo;t say it&rsquo;s
 been easy, but with clear architecture up front, we&rsquo;re doing pretty well.</p></li>
<li><p><strong>Slow, complex build tools</strong></p>

<p> Sourcegraph doesn&rsquo;t like <a href="http://joshdmiller.github.io/ng-boilerplate/#/home">ng-boilerplate</a>. They find Grunt configurations
 complex, and FE build tools too slow. I guess they&rsquo;ve never compiled a QT C++
 application. JS build times are teh slowz! they say. And ngmin takes forever!</p>

<p> I agree, ngbp has a mediocre Gruntfile at best. At Novus, we have IMHO a much
 better setup. Currently, we can run our entire build suite, including feature
 tests, in about a minute; that&rsquo;s six projects, three of which can be run
 parallel, and 30 seconds of feature testing (more in 4). Each project,
 individually, takes about a half second to lint &amp; build, and another 2 to 5
 seconds to run their full suite of tests (between a dozen and half-a-hundred,
 but growing). We have several mechanisms in place to pare down the test run, to
 only run the tests of the component under active development.</p>

<p> Don&rsquo;t get me wrong, the last project I was on had single-module build times of
 over a minute (on the lead devs machine; another guy was getting three-plus minute build
 times for CSS changes). You can write bad build configurations. We haven&rsquo;t.</p>

<p> Oh, if you want to see parts of our kick-ass build process, check out my
 <a href="http://davidsouther.com/tdd-angular/">TDD AngularJS tutorial</a>.</p></li>
<li><p><strong>Slow, flaky tests</strong></p>

<p> Sourcegraph seems to have problems with browser-based feature tests. It took us
 all of 8 lines in 3 config files to set up and run headless Firefox on our CI
 server. Running the entire Browserstack matrix is going to be a different beast,
 but that&rsquo;s because of our IT department&rsquo;s (justified) security concerns. As for
 the &ldquo;flakiness&rdquo; of the tests, every time we&rsquo;ve had a feature test fail, it&rsquo;s
 been because of a real regression we introduced into the codebase.</p>

<p> We&rsquo;ve taken an approach to feature testing that I&rsquo;ve outlined as the
 <a href="http://davidsouther.com/2014/01/cucumber-selenium-mappings-model/">Cucumber Selenium Mapping Model</a>. It&rsquo;s served us fantastically well, and I&rsquo;d
 encourage others to take a look at it.</p></li>
<li><p><strong>Slowness is swept under the rug, not addressed</strong></p>

<p> Sourcegraph claims SPAs make it easier to ignore performance issues. This is not
 an argument about SPAs, this is an argument against lazy programmers.</p>

<p> I&rsquo;m about 4 hours in to re-architecting our page load/event flow because our
 page has been loading too slowly. I have test harness code designed specifically
 to introduce slowness into our system, to emulate long/hung/failed/exceptional
 asynch requests, to see how well they&rsquo;re handled. I am doing this, because our
 UX lead has been complaining (and I&rsquo;ve been noticing) stutterings in the UI,
 which our metrics show are happening on requests that are, get this, over ~200
 milliseconds.</p>

<p> Angular does not make a page laggy, bad programmers make a page laggy.</p></li>
</ol>


<h2>Choose the right tool</h2>

<p>Sourcegraph&rsquo;s closing line is a fine token gesture, &ldquo;[Angular wasn&rsquo;t] the right
tool for our site.&rdquo; Looking at their site agnd team, I&rsquo;d tend to agree. I don&rsquo;t
know how I&rsquo;d have architected it up front, but Angular (and indeed, SPAs) are
not the best option for a small to medium traffic volume static on demand site.
That is not a reason to decry all front end build tools as an immense web of
problems.</p>

<p>I don&rsquo;t know why they published their piece &ndash; they must be having (or have had)
some frustrations. I am here to tell you that none of these needed to be
problems. If you have a site that you think needs Angular, these problems have
solutions. Better than that, many will not be problems, if you take a bit of
pride and architecture in your projects.</p>

<p>Happy hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cucumber Selenium Mappings Model]]></title>
    <link href="http://DavidSouther.github.io/2014/01/cucumber-selenium-mappings-model"/>
    <updated>2014-01-27T10:52:00-05:00</updated>
    <id>http://DavidSouther.github.io/2014/01/cucumber-selenium-mappings-model</id>
    <content type="html"><![CDATA[<p>To create a ubiquitous language for a project&rsquo;s interface, I recommend creating
a semantic mapping. This is an in-code key/value object defining words and
phrases in a <a href="http://martinfowler.com/bliki/UbiquitousLanguage.html">ubiquitous language</a> that maps to a specific CSS
selector for use in code. This has many advantages, with a couple draw backs.
The benefits of having a ubiquitous language are documented in various sources,
but in sum, mean less time wasted in a team discussing which piece of the
solution is under discussion. This exact solution has some specific drawbacks,
that I&rsquo;ll mention later.</p>

<!-- more -->


<p>A Cuke mapping, here, is a set of nouns and noun phrases that describe some part
of a DOM interface. In one example, the application has a main content area. The
mapping is relatively simple: <code>'main content': '#main'</code> (coffeescript key/value
bare object). The same application has two distinct menu areas, which are mapped
with <code>'main menu': 'main [tab-nav="tab-nav"]'</code> and <code>'page menu': 'main div
[tab-nav="tab-nav"]'</code>. The subtleties in DOM structure are hidden behind this
mappings concept. If the DOM changes, the tests can be fixed by eding the
selector in a single place.</p>

<h2>Given/When/Then</h2>

<p>Short aside to cover the basics of Cuke best practices. As is recommended in
automated testing scenarios, each test has five phases. Two of those phases are
hidden in the test harness, the before and after test setup phases. The test
itself is broken into application state setup, taking an action, and asserting
aspects of the final state. Yes, testing is exercising the big old state
machine of your application &ndash; put the program in some state, take an action,
make sure it&rsquo;s in the expected next state.</p>

<p>In Cucumber, these phases are described with the phrases <code>Given</code>, <code>When</code>, and
<code>Then</code>. The <code>Given</code> assertions are grouped at the beginning of the test, where
they include things specific to the test that the <code>Before</code> steps haven&rsquo;t
covered. For a large application I work on, <code>Before</code> guarantees the browser will
be open, and on the root page of the application (<code>http://localhost:1024/</code>).
Because of this, we sometimes drop the <code>Given</code> state, or use a dummy noop step,
<code>Given the user is on the home page</code>. However, when verifying some action on a
specific page, we will use <code>Given</code> to navigate to the page under test. <code>Given
the user navigates to "Performance" "Summary"</code>.</p>

<p>The <code>When</code> and <code>Then</code> tests are pretty straightforward, and for this application
generally click some DOM node, then check some other DOM status, often for the
presence of a string in text, or the presence or absence of a node. Some of our
tests, however, assert rendered properties, especially dimension constraints.
For instance, we have asserts to check if elements of the page are on the top,
left, or center of a page, or meet certain minimum and maximum size constraints.
Finally, we have tests that assert look and feel by comparing screenshot image
differences.</p>

<p>There is some discretion in choosing when to use <code>Given</code> vs when to use
<code>When</code> &ndash; are the values filled in a form part of the given condition, or part of
the test action? I find this depends on what state transition is under test. If
the test is verifying the form shows validation rules for invalid input, the
form filling should be a <code>When</code> statement. On the other hand, if the test is
verifying a &ldquo;Thanks for shopping!&rdquo; page, the form should be filled in <code>Given</code>
steps. Cucumber itself relaxes constraints, and doesn&rsquo;t actually enforce only
steps only run in their defined phase, so in reality any step can match
anywhere.</p>

<h2>Mappings</h2>

<p>When writing steps, cucumber uses regular expression matching groups to pass
arguments to the step body. Generally, these the form <code>/"([^"]+)"/</code>, matching
any non-zero length of string inside double quotation marks. That value then is
passed to the step definition function, in argument order. For cuke mappings, we
constrain the valid items within quotes, to either be a key in the mappings
table, or a string literal to assert in some test.</p>

<p>Here&rsquo;s a line from our tests.</p>

<p>```
Then the &ldquo;header nav&rdquo; should have links to</p>

<pre><code>"""
Dashboard
Portfolios
"""
</code></pre>

<p>```</p>

<p>The step definition matches the first quote group against the mappings object,
here finding the expression <code>"#header nav"</code> as the CSS to select with. It can
then look for links to each of the titles in the list of expected links. The
full step is defined as</p>

<p>```coffeescript</p>

<pre><code>@Then /"([^"]+)" should have links to/, (selector, list)-&gt;
    selector = mappings[selector] + ' a'
    @world.text(selector)
    .then (text)-&gt;
        for link in list.split '\n'
            text.indexOf(link).should.be.greaterThan -1
</code></pre>

<p>```</p>

<p>This test creates a selector by looking for any <code>a</code> children of the selector
for <code>"header nav"</code>, asking the world to return the joined text for all those
elements, and asserting that each link text is in that joined string. Also, this
test is using the <a href="https://github.com/DavidSouther/qcumber">qcumber</a> cucumberjs library, which makes steps
behave with promises &ndash; a step can return a value, throw an exception, or return
a promise. It will pass if a value is returned or a returned promise resolves,
and will fail if an exception is thrown, or a returned promise rejects.</p>

<h2>World</h2>

<p>The world object abstracts the details of working with a browser backend. This
allows an abstraction between the steps' browser interaction, and the actual
browser backend. Most commonly, <code>selenium-webdriver</code> serves as the browser
backend, but that could be replaced with <code>browserstack-webdriver</code> for
<a href="http://www.browserstack.com/">browserstack</a> testing in CI or <a href="http://zombie.labnotes.org/">Zombie</a>, for headless,
pure-js testing. This extra abstraction provides a minimal jquery-esque API for
retrieving DOM content, across possible browser backends.</p>

<p>```coffeescript
module.exports = class World</p>

<pre><code>constructor: (capabilities = {browserName: "firefox"})-&gt;
    @driver = new webdriver.Builder().
        usingServer(process.env.SELENIUM_HUB).
        withCapabilities(capabilities).build()

    @driver.manage().timeouts().setScriptTimeout(10000)

#...

find: (selector)-&gt;
    @driver.findElement By.css selector

#...

text: (where)-&gt;
    @find(where).getText()
</code></pre>

<p>```</p>

<p>This world is an object instance that configures itself using some webdriver,
and has a method to do CSS lookup. It&rsquo;s taken from <a href="https://github.com/DavidSouther/qcumberbatch">qcumberbatch</a>,
a library I have that implements the concepts here.</p>

<h2>Limitations &amp; Benefits</h2>

<p>The largest intrinsic drawback in this approach is the lack of flexibility in
constructing selectors on the fly. While nothing in the code prevents it, it is
discouraged to build such selectors, because anything you&rsquo;d need to select in
the DOM should have its own name, listed in the mappings. Those names must be
part of the project as a whole, and known and agreed to (at least in
conversation) by not only the product team, but the entire product stakeholder
group. When dicussing the application, stakeholders must take care to use these
phrases from the ubiquitous language.</p>

<p>This, while taking discipline, becomes one benefit of this ubiquitous language
and mapping approach. Because there is a very limited subset of language to use
for the project, conversations spend less time mucking over meaning of words.
The meaning has already been defined and agreed to, and any mention of a phrase
is immediately understood. The tradeoff of extra work and discipline pays for
itseld in improved communication.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Mock Render]]></title>
    <link href="http://DavidSouther.github.io/2014/01/angularjs-mock-render"/>
    <updated>2014-01-05T11:30:00-05:00</updated>
    <id>http://DavidSouther.github.io/2014/01/angularjs-mock-render</id>
    <content type="html"><![CDATA[<p>We test. A lot. We have quite a few directives. We&rsquo;re using this mock render
function to quickly test those directives. It takes the simple html name of the
directive, an object with any parent scope properties, an object with any DOM
attributes to set, and a string to use for transclusion: <code>render(directive,
data = {}, attributes = {}, transclude = "")</code></p>

<!-- more -->


<p>```coffeescript render.coffee
toKeyVal = (attributes, separator = &lsquo; &rsquo;)&ndash;></p>

<pre><code>("#{key} = \"#{val}\"" for key, val of attributes)
    .join separator
</code></pre>

<p>if angular.mock</p>

<pre><code>window.render = angular.mock.render =
(directive, data = {}, attributes = {}, transclude = "")-&gt;
    $element = null
    inject ($compile, $rootScope)-&gt;
        $scope = $rootScope.$new()
        $scope[key] = val for key, val of data
        attributes = toKeyVal attributes

        template = $compile(
            "&lt;div #{directive} #{attributes}&gt;#{transclude}&lt;/div&gt;"
        )
        $element = template($scope)

        try $scope.$digest()
    $element
</code></pre>

<p>```</p>

<p>Its usage is pretty straight forward. Here, we are testing a directive that
emits some event when it has finished rendering data received from the
$httpBackend (configued elsewhere). We render the element, listen for the render
event when we&rsquo;ll run our test assertions, and flush the http backend to force
Angular to digest all the changes in the app. In this way, our test setup and
action phases are drastically simplified. Our test code shows the assertions our
business demands, not the setup our platform happens to use.</p>

<p>```coffeescript
should = chai.should()
describe &lsquo;Performance Overview&rsquo;, &ndash;></p>

<pre><code>describe 'directive', -&gt;

    beforeEach module 'nv-waves'

    it 'has some chart stuff.', -&gt; inject ($rootScope, $httpBackend)-&gt;
        $element = render 'performance-summary'

        $rootScope.$on 'Wave Rendered', -&gt;
            $element.find('svg').length.should.equal 2
            $element[0].querySelectorAll('.chart').length.should.equal 2
            $element[0].querySelectorAll('.grid').length.should.equal 2
            $element.scope().data.header.sortable.should.equal true

        $httpBackend.flush()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing. It's Hard. Just Do It!]]></title>
    <link href="http://DavidSouther.github.io/2013/10/testing-its-hard-just-do-it"/>
    <updated>2013-10-30T13:31:11-04:00</updated>
    <id>http://DavidSouther.github.io/2013/10/testing-its-hard-just-do-it</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Linus's_Law">&ldquo;With enough eyeballs, all bugs are shallow.&rdquo;</a></p>

<p>The bug might be shallow when it&rsquo;s first found, but how does it never happen again? Automated Testing. When a bug is found, prove it exists with a test. Then, that bug is guaranteed to never happen again &ndash; a little computer gremlin with eagle-eye focus will look at that bug every time your program runs, and the bug will NEVER HAPPEN AGAIN. It will never happen, because if you come close to making that bug, the gremlin will make your console bleed with the red of a failed test.</p>

<blockquote><p>&ldquo;The three chief virtues of a programmer are: Laziness, Impatience and Hubris.&rdquo;
&ndash; Larry Wall (creator of Perl)</p></blockquote>

<!-- more -->


<p>That little gremlin I wrote to prove the (non)existence of a bug? That&rsquo;s me being lazy. I have absolutely zero desire to fix a bug a second time &ndash; that&rsquo;s time I could be playing ping pong, or writing a new operating system. That little gremlin better be fast, too, or I&rsquo;m not going to wait around for him. The gremlin must be small and focused, with a family of small, focused gremlins that can run all my critical tests (the features I&rsquo;m touching) in under 5 seconds, and my entire codebase quickly enough to not block anyone else on my team (<a href="http://codeascraft.com/2013/09/23/lxc-running-14000-tests-per-day-and-beyond-part-1/">or they will not test, because it takes too long to be useful</a>). My code always works correctly, the first time. At least, it does every time I write a test before I write a feature. I know most developers aren&rsquo;t as egotistical as I am, but I don&rsquo;t know a single good developer who doesn&rsquo;t want to take pride in the code they&rsquo;ve written. It&rsquo;s damned easy to take pride in code that Works Right.</p>

<h2>Why don&rsquo;t I test more often?</h2>

<p><span style="float:right"><img src="https://lh3.googleusercontent.com/OkcCl_KVOvD6J7q4w_mWsgvj01mc_3jqS_fKcKIZbJDqq5HMCoPE0J2fnJld_XA9Zxs21XSH429Rnwk9V-T_MHB19-Wk090pYtvHD0pGOUdf_QKls6HXaX-dUA" /></span></p>

<p>Testing is hard. It&rsquo;s not the way most programmers learned to program. The other side of the laziness sword? If it&rsquo;s easier to take a shortcut, to get code out the door, I probably will. Testing is in many cases as hard as writing production code, but for a completely different reason: testing requires discipline. Discipline is not, in my experience, something prided by the great hackers of our field. It is a completely different way to approach building software, and requires an equal level of commitment and experience to become comfortable for a developer or team. Without that discipline, shortcuts will happen, and developers won&rsquo;t write code.</p>

<p>Three things need to happen when a team gets to that point. The tests need to be easier to write. This is half experience and half toolkit &ndash; the test suite must be fast to run and easy to add tests, and I personally need to be familiar enough with the testing library to write the tests. The test suite must run, and pass, before any code is allowed out the door (coverage testing will guarantee a level of certainty that tests have indeed been written). The third and equally critical piece is support from the project&rsquo;s leadership. If the leadership of the team allows developers to slide and be (bad) lazy, testing will slip.</p>

<h3>Metaphorical Interlude</h3>

<pre>
           Drawing from a well,

       Deep and full and crystal clear.

         A ratchet won't slip.
</pre>


<p><span style="float:left"><img src="https://lh4.googleusercontent.com/4dgJC56kg--PvW2NHWSTtKr6H0RbQHFAi4pKitQOyUhOBT0KgAyX_Yau1efUdBnI4USrPk63-KEBB9Twrd-yRK8nN_yevJLYOpOullHdpi0hmpdHQgblbjwQYw" /></span></p>

<p>Programming is like drawing water from a well. When the well is shallow, and the bucket small, it&rsquo;s not too difficult a task. When the bucket is big, and the well deep, it becomes harder to draw the bucket, and every mistake can be more disastrous. Automated testing is like installing a ratchet on the rope &ndash; every time you write tested code, that bit of rope will never slip. Embracing test driven development is installing a pulley to hoist the bucket with the program. The force and exertion to write a feature halves, because you only write the actual half of the feature the customer needs.</p>

<h2>Excoriation of Excuses</h2>

<p>If you&rsquo;re a programmer and you don&rsquo;t write tests, I&rsquo;m going to assume you don&rsquo;t care enough about your code. I&rsquo;m going to assume that the code you&rsquo;re working on, you&rsquo;re fine with it being 80%. I&rsquo;m going to assume you are smarter than me, in a bad way. I am not smart enough to know whether I did or did not break the code you wrote, if I don&rsquo;t have a test suite that tells me if I broke it or not. I am probably not going to want to work on your project or component. I say this not because I think less of you, or want to belittle you, but because this is as much a wake-up call to myself. I say this to myself when I visit old code of my own, that I wrote without tests. It is disgusting and reprehensible to visit those code bases, and I have no desire to return to those projects, no matter how well intentioned they were.</p>

<p>If you&rsquo;re a manager and don&rsquo;t demand your team writes tests, I&rsquo;m going to assume you&rsquo;re penny-wise and pound-foolish. If your project is doing well now, I will put money on it collapsing with a bit of churn in your team. After about a quarter of your team has moved on or been replaced, your codebase will collapse into a mess of hard to find bugs, weird edge cases, and increasingly continued pressure to deliver new features when your team is simply unable to write a line of code that doesn&rsquo;t unexpectedly change behavior elsewhere in the application. I will not volunteer for your team. Similarly, if I ever find myself leading a team in such a position, I would be incredibly reticent to hire a developer willing to work in my environment. (Unless, of course, I am being hired or hiring a <a href="https://www.google.com/about/jobs/search/#!t=jo&amp;jid=35182&amp;">Software Engineer in Test</a> specifically to fix these testing deficiencies.)</p>

<h2>Prototypes, Too!</h2>

<p><span style="float:right"><img alt="Evils of the Refactoring Cat" src="http://davidsouther.com/assets/images/Code-Refactoring-Cat-in-Bathtub.gif" /></span></p>

<p>I reject the concept of one-off code. If you&rsquo;re at a hackathon, there is that point, about three hours before demo, where your project is AWESOME, and going to win best of show, but you have three hours so you might as well implement a new feature. Without tests, your demo will fail. You will accidentally, in the heat of the moment, break the old, MVP feature with that whiz-bang animation, and have no idea how to get back. At best, you will have a commit to roll back to. At worst, your hackathon time was ruined. With a prototype, you are trying to convince someone to go out of their way to do you a favor. Don&rsquo;t play the lottery &ndash; write tests.</p>

<h2>Call to Action</h2>

<p>At this point, it should be pretty clear I care, very deeply, about code and code quality. I want to use good software, and I want to write good software. Help me! If you write code, find a way to test! Challenge me! Don&rsquo;t let me off the hook when testing gets hard, and I won&rsquo;t let you! Together we can craft better software!</p>

<h3>Some resources for getting on the testing train:</h3>

<ul>
<li><a href="http://www.codinghorror.com/blog/2006/07/i-pity-the-fool-who-doesnt-write-unit-tests.html">I Pity the Fool</a></li>
<li><a href="http://www.amazon.com/exec/obidos/ISBN=0131177052/portlandpatternrA/">Working Effectively with Legacy Code</a> &ndash; <a href="http://www.objectmentor.com/resources/articles/WorkingEffectivelyWithLegacyCode.pdf">Intro PDF</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/gg655487.aspx">Unit Testing 101: Are you testing your javascript?</a></li>
<li><a href="http://www.obeythetestinggoat.com/">Obey the Testing Goat</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Readable D3]]></title>
    <link href="http://DavidSouther.github.io/2013/02/readable-d3"/>
    <updated>2013-02-25T22:26:58-05:00</updated>
    <id>http://DavidSouther.github.io/2013/02/readable-d3</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/mbostock/d3/wiki/Gallery">d3 example code</a> is horribly convoluted, depending on dozens of unstructured variables (and often some global magic) to achieve even the simplest effects. To improve the readability of my d3 projects, I&rsquo;ve introduced a Canvas container, with the most commonly used properties conveniently encapsulated in a single object. Combined with mbostocks discussion in <a href="http://bost.ocks.org/mike/chart/">Towards Reusable Charts</a>, the canvas container can be used in nearly any project to greatly improve the structure and quality of d3 code.</p>

<!-- more -->


<p>```javascript &ldquo;Readable Canvas (canvas.js)&rdquo; <a href="https://gist.github.com/DavidSouther/5035560#file-canvas-js">https://gist.github.com/DavidSouther/5035560#file-canvas-js</a>
(function(){
  /*</p>

<pre><code>Get a new SVG canvas, with margins and scales. Pass an object as `options` to
set values. Defaults:

{
  size: # Size of SVG. Returned size will be smaller by the size of the margins.
    width: 960
    height: 500
  margin: # Margins for the graphic.
    top: 20
    right: 20
    bottom: 30
    left: 40
  scale: # d3.scales to scale against the canvas
    x: linear
    y: linear
  domain: # Domain of scales for the canvas.
    x: [0, 1]
    y: [0, 1]
}

@param root String selector for finding the SVG element.
@param options Object matching the defaults to override.
@return Object with defaults, overriden by the options, and an additional two properties:
  {
    svg: SVG_Element # SVG root
    defs: SVG_Defs_Element # &lt;defs&gt; to attach gradient and filter definitions to.
  }
</code></pre>

<p>  */
  this.Canvas = function(root, options){</p>

<pre><code>var margin, width, height, svg, scales, canvas;
root == null &amp;&amp; (root = 'body');
options == null &amp;&amp; (options = {});
options.size || (options.size = {});
options.margin || (options.margin = {});
options.scale || (options.scale = {});
margin = {
  top: options.margin.top || 20,
  right: options.margin.top || 20,
  bottom: options.margin.top || 30,
  left: options.margin.top || 40
};
margin.leftright = margin.left + margin.right;
margin.topbottom = margin.top + margin.bottom;
width = (options.size.width || 960) - margin.leftright;
height = (options.size.height || 500) - margin.topbottom;
svg = d3.select(root).attr({
  'width': width + margin.left + margin.right,
  'height': height + margin.top + margin.bottom
});
scales = {
  x: d3.scale[options.scale.x || 'linear']().range([0, width]).domain(options.domain.x || [0, 1]).nice(),
  y: d3.scale[options.scale.y || 'linear']().range([0, height]).domain(options.domain.y || [0, 1]).nice()
};
canvas = {
  size: {
    width: width,
    height: height
  },
  margin: margin,
  scale: scales,
  svg: svg,
  defs: svg.select('defs')
};
return canvas;
</code></pre>

<p>  };
}).call(this);
```</p>

<p>This version binds the Canvas closure function to Window. Most of the code is to ensure the appropriate fields are set on the options object. The returned object has the final details of the drawing surface, including its size, the margins, and d3 scales calibrated to the canvas' coordinates. It also includes a refernce to the root SVG element, as well as the svg:defs element containing any filters or gradients defined for the image.</p>

<p>This object works exceptionally well as the config parameter for reusable charts.</p>

<p>```javascript Herzsprung Russel Diagram (starmap.js) <a href="https://gist.github.com/DavidSouther/5035560#file-starmap-js">https://gist.github.com/DavidSouther/5035560#file-starmap-js</a>
(function(){
  var spectrate, Starmap, prepare;</p>

<p>  // Small helper to look up a string
  spectrate = function(star){</p>

<pre><code>return "class" + spectral['class'](+star.temp);
</code></pre>

<p>  };</p>

<p>  // Given a canvas, add gradient definitions to the svg:defs element.
  prepare = function(canvas){</p>

<pre><code>var defs, grads;
defs = canvas.defs;
grads = defs.selectAll('radialGradient')
  // A list of spectral classes
  .data(spectral.spectro)
  .enter()
  .append('svg:radialGradient')
  .attr({
    'id': function(it){ return spectrate(it); },
    'cx': +0.5,
    'cy': +0.5,
    'r': +1
  });
grads.append('stop')
  .attr({
    'stop-color': function(it){ return it.color.brighter(); },
    'offset', '0%'
  });
grads.append('stop')
  .attr({
    'stop-color': function(it){ return it.color; },
    'offset': '100%'
  });
</code></pre>

<p>  };</p>

<p>  this.Starmap = function(canvas){</p>

<pre><code>var star;
prepare(canvas);

// Callable function to draw circles in a selection
// EG a stencil
star = function(selection){
  var circles;
  circles = selection.enter()
    .append('svg:circle')
    .attr({
      "r": 20,
      "class": "star"
    })
    .style({
      "opacity": 0.9
    });
  circles.attr({
    "cx": function(it){ return canvas.scale.x(+it.temp); },
    "cy": function(it){ return canvas.scale.y(+it.mag); },
    "fill": function(it){ return "url(#" + spectrate(it) + ")"; }
  });
  selection.exit().remove();
};

// The main stencil. Takes an svg:g layer from inside canvas.svg
return function(layer){
  // Load the spectrum data
  d3.csv("hr.csv", function(error, stars){
    layer.attr({
        'id': "herzrus",
        'transform': "translate(" + canvas.margin.left + ", " + canvas.margin.right + ")"
      })
      .style('opacity', 0.9)
      .selectAll('.star')
      .data(stars)
      // Chained call to the reusable star stencil.
      .call(star);
  });
};
</code></pre>

<p>  });
}).call(this);
```</p>

<p>In this example, StarMap will draw a Herzsprung Russel diagram on the layer. An HR diagram is a log-linear scatterplot of stellar temperature to luminosity. This example takes a canvas to attach Gradient definitions to, and returns a function that will draw the HR diagram on a layer. The stencil function loads data from a CSV file, and uses an inner stencil funtion to draw the individual stars.</p>

<p>Using the two is similarly easy.</p>

<p>```html Starmap <a href="https://gist.github.com/DavidSouther/5035560#file-starmap-html">https://gist.github.com/DavidSouther/5035560#file-starmap-html</a>
&lt;!DOCTYPE html>
<html>
<head></p>

<pre><code>&lt;title&gt;HR in D3&lt;/title&gt;
&lt;script src="http://d3js.org/d3.v3.min.js" /&gt;
&lt;link rel="stylesheet" href="styles/nucleosynth.css"&gt;
&lt;script src="canvas.js" /&gt;
&lt;script src="starmap.js" /&gt;
</code></pre>

<p></head>
<body></p>

<pre><code>&lt;svg id="chart"&gt;
    &lt;defs&gt;
        &lt;filter id="oil" filterUnits="objectBoundingBox" x="0%" y="0%" width="100%" height="100%"&gt;
            &lt;femorphology in="SourceGraphic" radius="2" result="result_oil_morph" /&gt;
            &lt;feturbulence type="turbulence" baseFrequency="0.05" numOctaves="2" result="result_oil_turb" /&gt;
            &lt;fedisplacementmap in="result_oil_morph" in2="result_oil_turb" scale=4 xChannelSelector="R" yChannelSelector="G" /&gt;
        &lt;/filter&gt;
    &lt;/defs&gt;
&lt;/svg&gt;
&lt;script type="text/javascript"&gt;
    var background;
    canvas = Canvas('#chart', {
        scale: {
            x: 'log'
        },
        domain: {
            x: [100000, 1000],
            y: [-8, 7]
        }
    });
    background = canvas.svg.append('svg:g')
        .attr('style', 'filter:url(#oil);');
    background.append('svg:image')
        .attr({
            'xlink:href': "assets/dfb.png",
            'width': canvas.size.width + canvas.margin.leftright,
            'height': canvas.size.height + canvas.margin.topbottom,
            'x': 0,
            'y': 0
        });
    Starmap(canvas)(background.append('svg:g'));
&lt;/script&gt;
</code></pre>

<p></body>
```</p>

<p>In this example, the SVG is preloaded in the HTML with a filter already defined. The script gets a canvas with a few custom properties, attaches a background image, then creates the Starmap and uses it immediately.</p>

<p>This pattern has been very helpful keeping my code clean.</p>
]]></content>
  </entry>
  
</feed>
